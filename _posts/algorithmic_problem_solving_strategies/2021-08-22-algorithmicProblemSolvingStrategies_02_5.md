---
toc: true
toc_label: "Table of Contents"
toc_icon: "cog"
toc_sticky: true

layout:
title: "[알고리즘 문제 해결 전략] 5 알고리즘의 정당성 증명"
excerpt: "5.1 도입, 5.2 수학적 귀납법과 반복문 불변식, 5.3 귀류법, 5.4 다른 기술들"
date: 2021-08-22
last_modified_at: 2021-08-22
categories:
  -
tags:
  - [알고리즘, 알고리즘 문제 해결 전략]

use_math: true
comments: true
share: false
---

📖[알고리즘 문제 해결 전략] 목차

<details>
<summary>01 문제 해결 시작하기</summary>
<div markdown="1">
  - [2 문제 해결 개관](/algorithmicProblemSolvingStrategies_01_2) <br>
  - [3 코딩과 디버깅에 관하여(1)](/algorithmicProblemSolvingStrategies_01_3(1)) <br>
  - [3 코딩과 디버깅에 관하여(2)](/algorithmicProblemSolvingStrategies_01_3(2))
</div>
</details>

<details>
<summary>02 알고리즘 분석</summary>
<div markdown="1">       
   - [4 알고리즘의 시간 복잡도 분석(1)](/algorithmicProblemSolvingStrategies_02_4(1)) <br>
   - [4 알고리즘의 시간 복잡도 분석(2)](/algorithmicProblemSolvingStrategies_02_4(2)) <br>
   - [5 알고리즘의 정당성 증명](/algorithmicProblemSolvingStrategies_02_5) <br>
</div>
</details>

<details>
<summary>03 알고리즘 설계 패러다임</summary>
<div markdown="1">       
   - [6 무식하게 풀기]()<br>
   - [7 분할 정복]()<br>
   - [8 동적 계획법]()<br>
   - [9 동적 계획법 테크닉]()<br>
   - [10 탐욕법]()<br>
   - [11 조합 탐색]()<br>
   - [12 최적화 문제 결정 문제로 바꿔 풀기]()<br>
</div>
</details>

<details>
<summary>04 유명한 알고리즘들</summary>
<div markdown="1">
    - [13 수치 해석]()<br>
    - [14 정수론]()<br>
    - [15 계산 기하]() <br>
</div>
</details>

<details>
<summary>05 기초 자료 구조</summary>
<div markdown="1">
    - [16 비트마스크]()<br>
    - [17 부분 합]()<br>
    - [18 선형 자료 구조]()<br>
    - [19 큐와 스택, 데크]()<br>
    - [20 문자열]()<br>
</div>
</details>
 
<details>
<summary>06 트리</summary>
<div markdown="1">
    - [21 트리의 구현과 순회]()<br>
    - [22 이진 검색 트리]()<br>
    - [23 우선순위 큐와 힙]()<br>
    - [24 구간 트리]()<br>
    - [25 상호 배타적 집합]()<br>
    - [26 트라이]()<br>
</div>
</details>

<details>
<summary>07 그래프</summary>
<div markdown="1">
    - [27 그래프의 표현과 정의]()<br>
    - [28 그래프의 깊이 우선 탐색]()<br>
    - [29 그래프의 너비 우선 탐색]()<br>
    - [30 최단 경로 알고리즘]()<br>
    - [31 최소 스패닝 트리]()<br>
    - [32 네트워크 유량]()<br>
</div>
</details>

---

<div style="text-align: right"> 02 알고리즘 분석 </div>

## 5 알고리즘의 정당성 증명

### 5.1 도입

- 알고리즘의 정당성 증명  
  알고리즘이 문제를 제대로 해결하는지를 파악하기 위해 알고리즘의 정당성을 증명해야 합니다. 여러 입력에 대해 프로그램을 실행시켜보는 단위 테스트를 통해 증명할 수 있다고 생각할 수 있지만, 단위 테스트는 프로그램의 문제가 있음을 증명할 수 있어도 문제가 없음을 증명할 수는 없습니다. 따라서 알고리즘의 정확한 증명을 위해 각종 수학적인 기법을 사용해야 합니다. 대부분 프로그래머는 알고리즘을 만들기보다 이미 만들어져 있는 알고리즘을 사용하기에 알고리즘의 증명을 이해하는 공부가 필요합니다.
  <br>
  알고리즘의 증명을 공부해야 하는 가장 큰 이유는 많은 경우 증명이 알고리즘을 유도하는 데 결정적인 통찰을 담고 있기 때문입니다. 모든 알고리즘은 치열한 고민과 개선 과정을 거쳐 탄생하기에 결정적으로 필요한 깨달음이 증명에 담겨 있는 경우가 많습니다. 또한, 다른 알고리즘의 증명을 공부하다 보면 후에 자신이 설계할 알고리즘의 정당성을 더 쉽게 증명할 수 있다는 것이 또 다른 이유입니다. 많은 증명을 직접 따라 해 보면 처음 보는 알고리즘이 잘 작동할 수 있을지, 그리고 어떻게 그것을 증명해야 할지 알 수 있는 직관 같은 것이 생기기 때문입니다. 이 장에서는 알고리즘의 정당성 증명에서 흔히 나타나는 패턴들을 소개하고 몇 가지의 예제 증명들을 다루게 됩니다.
  <br>

### 5.2 수학적 귀납법과 반복문 불변식

- 수학적 귀납법

  100개의 도미노가 순서대로 놓여있고 다음 두 가지 사실을 안다고 가정합니다.  
  <br>
  · 첫 번째 도미노는 직접 손으로 밀어서 쓰러뜨린다.  
  · 한 도미노가 쓰러지면 다음 도미노 역시 반드시 쓰러진다.  
  <br>
  위의 두 사실로 첫 번째 도미노가 쓰러지면 마지막 도미노도 쓰러진다는 것을 직관적으로 알 수 있습니다. 수학적 귀납법(mathematical induction)은 이같이 반복적인 구조를 갖는 명제를 증명하는 데 유용하게 사용되는 증명 기법입니다. 귀납법 증명은 크게 세 가지로 나누어집니다.
  <br>

  > - 단계 나누기 : 증명하고 싶은 사실을 여러 단계로 나눕니다. 앞 예제에서는 100개의 도미노를 하나씩 나누는 것입니다.
  > - 첫 단계 증명 : 나뉜 단계 중 첫 단계에서 증명하고자 하는 내용이 성립함을 보입니다. 앞 예제에서는 첫 번째 도미노가 넘어지는 것을 증명하는 것입니다.
  > - 귀납 증명 : 한 단계에서 증명하고자 하는 내용이 성립한다면, 다음 단계에서도 성립함을 보입니다. 앞 예제에서 첫 번째 도미노가 쓰러지면 다음 도미노가 쓰러지는 것을 증명하는 것과 같습니다.

  실제 귀납법을 이용하여 사다리 게임을 증명해 봅니다. 사다리 게임의 출발지와 도착지가 반드시 1:1 대응인 것을 귀납법을 사용하여 쉽게 증명할 수 있습니다.

  · 단계 나누기 : 비어있는 $N$개의 세로줄에서부터 시작하여 가로줄을 하나씩 그어 원하는 사다리를 완성한다고 가정합니다. 이때 하나의 가로줄을 긋는 것을 한 단계로 가정합니다.
  · 첫 단계 증명 : 비어있는 $N$개의 세로줄에서는 항상 출발지와 도착지가 1:1 대응이 됩니다.
  · 귀납 증명 : 가로줄을 그어 두 세로줄을 연결한다면 두 세로줄의 결과는 서로 뒤바뀌게 됩니다. 세로줄의 결과가 뒤바뀌어도 1:1 대응은 유지되므로 가로줄을 계속 그어 세로줄의 결과가 계속 바뀌어도 모든 세로줄의 1:1 대응이 유지됩니다.

  ![5.2-ghostLeg](https://user-images.githubusercontent.com/58170545/130359946-986bfaea-4290-4c2a-afe6-b009ac718905.png){: .align-center}
  <br>

- 반복문 불변식  
  대부분 알고리즘은 반복적인 요소를 가지고 있기에 귀납법은 알고리즘의 정당성을 증명하기 위한 유용한 방법입니다. 귀납법은 알고리즘의 각 단계가 정답으로 가는 길 위에 있음을 보이고 결과적으로는 알고리즘의 답이 옮음을 보입니다. 반복문 불변식(loop-invariant)이란 마지막 정답의 계산을 위해 반복문의 중간 과정 식이 변하지 않는다는 조건입니다. 불변식을 이용하면 반복문의 정당성을 다음과 같이 증명할 수 있습니다.

  1. 반복문이 집입시에 불변식이 성립합을 보인다.
  2. 반복문 내용이 불변식을 깨뜨리지 않음을 보인다. 즉, 반복문 내용이 시작될 때 불변식이 성립했다면 반복문 내용이 끝날 때도 불변식이 항상 성립함을 보인다.
  3. 반복문 종료시에 불변식이 성립하면 항상 정답을 구했음을 보인다.

  1,2번을 증명했다면 수학적 귀납법을 이용해 이들은 반복문이 종료될 때까지 항상 불변식이 성립합을 보일 수 있습니다. 코드로 보는 예시는 다음과 같습니다.

  ```c++
  while(조건){
    // 반복문 내용의 시작
    ...
    // 반복문 내용의 끝
    // 불변식은 여기에서도 성립해야 한다.
  }
  ```

  <br>

- 이진 탐색과 반복문 불변식

  [문제]<br>
  필수 조건 : $A$는 오름차순으로 정렬되어 있다.
  결과 : $A[i-1]<x<=A[i]$인 $i$를 반환한다.
  $A[-1]=-∞, A[n]=∞$라고 가정

  반복문 불변식 ① $lo<hi$ ② $A[lo]<x<=A[hi]$

  ```c++
  int binserach(const vector<int>& A, int x){
    int n = A.size();
    int lo = -1, hi = n;
    //반복문 불변식 성립 범위 시작
    while(lo+1<hi){
      int mid=(lo+hi)/2;
      if(A[mid]<x) lo=mid;
      else hi=mid;
    //반복문 불변식 성립 범위 끝
    }
    return hi;
  }
  ```

  이진 탐색 예시에서 두 불변식이 while문이 완전히 종료하고 함수의 마지막 줄까지 계속 성립했다고 가정하면 다음 두 사실을 알 수 있습니다.

  · $lo+1=hi$ : while문이 종료되었기에 $lo+1>=hi$이고 불변식에 의해 $lo+1=hi$가 됩니다.  
  · $A[lo]<x≤A[hi]$ : 불변식이 성립된다고 가정하였기에 다음 식도 성립합니다.

  따라서 문제의 결과인 $i$는 $hi$라는 것을 알 수 있습니다. 불변식이 while문 종료시에도 항상 성립한다는 것을 보일 수 있다면 이 알고리즘의 정당성이 증명된 것입니다.

  불변식을 이용하여 증명하는 과정은 귀납법과 다르지 않습니다. 전체 작업을 각 단계로 나누는 부분이 반복문으로 나타나 있으므로 반복문의 처음에 해당 불변식이 성립함을 보이고 반복문의 마지막에도 계속 성립하는 것을 보이면 증명할 수 있습니다. 정리하면 다음과 같습니다.

  > 초기 조건 : $n=0$인 경우에도 ①을 만족하기 위해 $lo$와 $hi$는 초기값 $-1, n$으로 초기화하고 $A[-1]=-∞, A[n]=∞$라고 가정합니다.
  >
  > 유지 조건 : 반복문 내부에서 불변식이 유지됨을 보입니다.
  >
  > · 불변식 ① : while문 안에서는 lo와 hi의 차이가 항상 2 이상이므로 mid는 두 값 사이에 존재하고 $mid$를 어느것에 대입하더라도 성립하게 됩니다.  
  > · 불변식 ②  
  > (1) $A[mid]<x$인 경우 : 반복문을 시작할 때 이미 $x≤A[hi]$ 이므로 $A[mid]<x≤A[hi]$가 성립하고 $lo$에 $mid$를 넣어도 성립함을 알 수 있습니다.  
  > (2) $x≤A[mid]$인 경우 : 반복문을 시작할 때 $A[lo]<x$ 이므로 $A[lo]<x≤A[mid]$이므로 $hi$에 $mid$를 대입해도 성립함을 알 수 있습니다.

  위의 과정을 거쳐 반복문이 종료될 때 원하는 결과가 $A[hi]$에 저장되는 것을 알 수 있습니다.
