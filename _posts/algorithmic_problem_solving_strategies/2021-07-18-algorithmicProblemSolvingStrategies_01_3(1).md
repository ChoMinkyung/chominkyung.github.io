---
toc: true
toc_label: "Table of Contents"
toc_icon: "cog"
toc_sticky: true

layout:
title: "[알고리즘 문제 해결 전략] 3 코딩과 디버깅에 관하여(1)"
excerpt: "3.1 도입, 3.2 좋은 코드를 짜기 위한 원칙, 3.3 자주 하는 실수"
date: 2021-07-18
last_modified_at: 2021-07-25
categories:
  - APSS
tags:
  - [알고리즘, 알고리즘 문제 해결 전략]

use_math: false
comments: true
share: false
---

📖[알고리즘 문제 해결 전략] 목차

<details>
<summary>01 문제 해결 시작하기</summary>
<div markdown="1">
  - [2 문제 해결 개관](/algorithmicProblemSolvingStrategies_01_2) <br>
  - [3 코딩과 디버깅에 관하여(1)](/algorithmicProblemSolvingStrategies_01_3(1)) <br>
  - [3 코딩과 디버깅에 관하여(2)](/algorithmicProblemSolvingStrategies_01_3(2))
</div>
</details>

<details>
<summary>02 알고리즘 분석</summary>
<div markdown="1">       
   - [4 알고리즘의 시간 복잡도 분석(1)](/algorithmicProblemSolvingStrategies_02_4(1)) <br>
   - [4 알고리즘의 시간 복잡도 분석(2)](/algorithmicProblemSolvingStrategies_02_4(2)) <br>
   - [5 알고리즘의 정당성 증명](/algorithmicProblemSolvingStrategies_02_5) <br>
</div>
</details>

<details>
<summary>03 알고리즘 설계 패러다임</summary>
<div markdown="1">       
   - [6 무식하게 풀기]()<br>
   - [7 분할 정복]()<br>
   - [8 동적 계획법]()<br>
   - [9 동적 계획법 테크닉]()<br>
   - [10 탐욕법]()<br>
   - [11 조합 탐색]()<br>
   - [12 최적화 문제 결정 문제로 바꿔 풀기]()<br>
</div>
</details>

<details>
<summary>04 유명한 알고리즘들</summary>
<div markdown="1">
    - [13 수치 해석]()<br>
    - [14 정수론]()<br>
    - [15 계산 기하]() <br>
</div>
</details>

<details>
<summary>05 기초 자료 구조</summary>
<div markdown="1">
    - [16 비트마스크]()<br>
    - [17 부분 합]()<br>
    - [18 선형 자료 구조]()<br>
    - [19 큐와 스택, 데크]()<br>
    - [20 문자열]()<br>
</div>
</details>
 
<details>
<summary>06 트리</summary>
<div markdown="1">
    - [21 트리의 구현과 순회]()<br>
    - [22 이진 검색 트리]()<br>
    - [23 우선순위 큐와 힙]()<br>
    - [24 구간 트리]()<br>
    - [25 상호 배타적 집합]()<br>
    - [26 트라이]()<br>
</div>
</details>

<details>
<summary>07 그래프</summary>
<div markdown="1">
    - [27 그래프의 표현과 정의]()<br>
    - [28 그래프의 깊이 우선 탐색]()<br>
    - [29 그래프의 너비 우선 탐색]()<br>
    - [30 최단 경로 알고리즘]()<br>
    - [31 최소 스패닝 트리]()<br>
    - [32 네트워크 유량]()<br>
</div>
</details>

---

<div style="text-align: right"> 01 문제 해결 시작하기 </div>

## 3 코딩과 디버깅에 관하여(1)

### 3.1 도입 : 코딩의 중요성을 간과하지 말라

프로그램을 작성할 때 알고리즘과 자료 구조가 가장 중요한 것 같지만 알고리즘은 아무리 좋아도 모든 문제에 적용되지 않고 코딩 과정은 어떤 문제를 풀더라도 필요하기 때문에 코딩 능력이 가장 중요하다고 할 수 있습니다. 좋은 프로그램을 작성할 때 빠르게 코드를 작성하는 것 보다는 읽기 쉬운 코드를 작성하는 것이 중요합니다. 복잡하고 읽기도 어려운 코드는 디버깅도 어려울 뿐만 아니라 한 번에 정확하게 작성하는 것도 어렵기 때문입니다.

여기서 [디버깅](https://ko.wikipedia.org/wiki/%EB%94%94%EB%B2%84%EA%B7%B8)이란 컴퓨터 프로그램 개발 단계 중에 발생하는 시스템의 논리적인 오류나 비정상적 연산(버그)을 찾아내고 그 원인을 밝히고 수정하는 작업 과정을 뜻합니다. 즉, 코드에서의 버그를 제거해 프로그램이 효율적으로 잘 작동할 수 있도록 하는 것입니다. 코드에서 버그 및 오류를 수정하는 것은 시간이 많이 걸릴 수도 있고 매우 어려울 수도 있습니다. 그러므로 코드를 쉽고 간결하게 작성하여 디버깅 시간이 최대한 적게 걸릴 수 있도록 하는 것이 중요합니다.

### 3.2 좋은 코드를 짜기 위한 원칙

- 간결한 코드 작성하기

좋은 코드를 짜기 위해서는 오타나 단순 버그를 방지하여 디버깅이 쉽도록 코드를 짧고 간결하게 쓰는 것이 중요합니다. 이 원칙은 프로그래밍 대회의 문제를 푸는 것 뿐만 아니라 어느 프로그램을 작성하든지 동일하게 적용됩니다.

- 적극적으로 코드 재사용하기

간결한 코드를 작성하는 방법 중 하나는 코드를 모듈화하는 것, 즉 코드를 재사용하는 것입니다. 같은 코드가 세 번 이상 반복된다면 이들을 함수나 클래스로 분리해 재사용하여 코드를 짧고 간결하게 만드는 것입니다. 처음 코드를 작성할 때부터 함수화하는 것은 어렵고 귀찮은 일이라고 생각됩니다. 하지만 반복되는 코드를 함수로 만들어 사용하는 것이 당장은 큰 차이가 없어 보일지라도 코드를 함수화하는 것을 반복하다보면 코드를 간결하게 작성하는 것에 익숙해지고 처음 코드를 작성할 때부터 더 간결한 코드를 작성할 수 있게 될 것입니다. 이때 이상적으로 함수화를 하는 방법은 한 함수가 두 가지 이상의 일을 하지 않도록 하는 것입니다. 입력을 읽어들이는 함수, 입력을 처리하기 쉬운 형태로 바꾸는 함수, 실제 문제를 푸는 함수가 각각 분리되어 있어야 합니다. 다음과 같은 원칙을 잘 지켜 코드의 재사용을 습관화하다 보면 빠르게 간결한 코드를 작성할 수 있을 것입니다.

- 표준 라이브러리 공부하기

이미 만들어져있는 표준 라이브러리를 공부하면 더 간결한 코드를 작성할 수 있습니다. 간혹 큐나 스택과 같은 자료구조, 혹은 정렬 등의 기초적 알고리즘을 직접 작성하는 경우가 있습니다. 물론 자료구조와 알고리즘의 이해를 위해 이미 만들어져있는 라이브러리를 사용하지 않고 직접 코드를 구현해보는 경우가 있습니다. 하지만 실무에서는 굳이 코드를 직접 작성할 필요가 없습니다. 표준 라이브러리는 이미 많은 사람들이 사용되고 있으며 이미 많은 검증이 이루어 졌기에 메모리나 정당성 증명에 신경쓰지 않고 사용할 수 있습니다. 검증 문제 이외에도 실무에서는 다른 사람들과 협업을 하는 경우가 존재하기 때문에 다른 사람들도 코드를 쉽게 이해할 수 있도록 표준 라이브러리를 사용하는 것이 중요합니다. 따라서 표준 라이브러리에 대해 공부하여 사용법에 대해 알아두는 것은 필수적입니다.

- 항상 같은 형태로 프로그램을 작성하기

프로그램을 작성하다 보면 여러 종류의 코드를 반복적으로 작성하게 됩니다. 다양한 코드가 사용되기 때문에 사람들은 코드마다 다른 방식으로 코드를 작성하곤 합니다. 예를 들어 2차원 배열의 크기를 전달할 때 가로,세로 순으로 전달하다가 세로, 가로 순으로 바꿔 전달하는 경우가 있습니다. 처음에는 그 방법이 가장 좋아보일지라도 시간이 지날수록 점점 실수의 원인이 되어갑니다. 더 좋은 코드를 만들기 위해 꾸준히 생각하고 다양한 방법으로 시도해 볼 필요는 있지만 코드를 검증하는 과정이 쉽지 않기 때문에 매번 같은 코드를 작성할 때마다 새로운 방법으로 작성하기 보다 자주 작성하는 코드에 대해서는 이미 검증된 코드를 사용하고 꾸준히 사용할 필요가 있습니다.

- 일관적이고 명료한 명명법 사용하기

코드를 작성할 때 변수나 함수 이름을 설정해야 하는 경우에 많은 어려움을 겪곤 합니다. 하지만 명명법은 명료한 코드를 위해 매우 중요합니다. 모호하지 않은 변수명과 함수명을 사용하면 다음번의 코드 수정이나 다른 사람과의 코드 공유가 어렵습니다. 사용하는 언어의 표준 라이브러리에서 사용하는 명명 규약을 익혀 사용한다면 같은 코드라도 훨씬 명료해집니다.

명명 규약이란 네이밍 컨벤션(naming convention)이라고도 불러지며 변수나 함수의 이름을 정하는 규칙입니다. 언어에 따라서 같은 함수명도 getResult, get_result, GetResult 등으로 쓰는 방식이 달라질 수 있기 때문에 명명 규약을 익혀 사용해야 합니다.

- 모든 자료를 정규화해서 저장하기

같은 자료는 두 가지 형태로 저장하지 않고 정규화하는 것이 좋습니다. 같은 자료를 두 가지 형태로 저장하게 된다면 미묘한 버그들을 만들기 쉽습니다. 변수를 표현하는 경우 각각의 문자열 표현이 달라지기도 하며 해시 값이 달라지는 등의 문제가 발생합니다. 또한 프로그램이 시간을 표현할 경우 이것이 어떤 시간대로 저장되었는지 등 여러 사람이 함께 프로그램을 작성하는 경우 방법이 모두 섞이는 문제가 발생합니다. 문자열을 다루는 프로그램에서는 문자열의 인코딩 방식이 다르면 문자열을 다루기 어려워집니다. 따라서 프로그램이 자료를 입력받거나 계산하자마자 바로 정규화 과정이 필요합니다. 이상적으로는 자료를 표현하는 클래스의 생성자에서 정규화를 수행하거나 외부에서 자료를 입력받자마자 정규화를 수행하는 것이 필요합니다.

- 코드와 데이터를 분리하기

코드를 작성할 때 코드의 논리와 상관없는 데이터는 분리하는 것이 좋습니다. 이렇게 하면 코드의 양을 줄어 단순한 데이터 선언을 함수로 작성하는 등의 실수를 줄일 수 있습니다.

### 3.3 자주 하는 실수

같은 실수를 여러번 반복하는 것보다 처음 실수에서 배워 실수를 반복하지 않도록 하고 더 나아가 남의 실수에서 배워 유사한 실수를 하지 않도록 하는 것이 바람직합니다. 이런 의미에서 사람들이 흔히 저지르는 실수들을 공부하고자 합니다. <br><br>

- 산술 오버플로

계산 과정에서 변수의 표현 범위를 벗어나는 값을 사용할 때 나타나는 오류가 산술 오버플로입니다. 이것은 3.5절에서 더 자세히 다루도록 하겠습니다.
<br><br>

- 배열 범위 밖 원소에 접근

C/C++은 배열의 원소에 접근할 때 해당 인덱스가 배열 범위 안에 있는지 별도로 확인해주는 기능이 없습니다. 이것은 프로그램의 속도를 향상시켜 주지만 배열 범위 밖에 있는 원소에 접근할 때 발생하는 오류를 찾기는 매우 어렵습니다. 프로그램에서 런타임 오류를 내어 비정상 종료되는 경우 오류가 발생했다는 것을 알 수 있지만 오류도 나지 않으면서 이상한 결과를 출력하는 경우도 있습니다. 따라서 배열 범위 밖 원소에 접근하는 오류를 범하지 않도록 배열의 크기를 정할 때 계산을 신중하게 해야합니다. 또한 배열의 범위는 기본적으로 0부터 시작하기 때문에 배열의 범위를 1부터 시작하는 등 배열의 범위를 혼동하지 않도록 해야합니다. 예를 들어 각 달의 날짜 수를 저장하는 배열 monthDay[12]가 있을 때 1월의 날짜 수를 index가 1인 monthDay[1]에 저장한다면 12월의 날짜 수를 저장할 땐 monthDay[12]에 저장하게 되어 존재하지 않은 위치에 접근하게 되는 것 입니다.
<br><br>

- 일관되지 않은 범위 표현 방식 사용하기

배열의 잘못된 위치를 참조하는 오류가 발생하는 큰 원인 중 하나로, 프로그램 내에서 범위 표현 방식을 섞어 쓰는 경우가 있습니다. 범위를 표현하는 방식에는 열린 구간, 닫힌 구간, 반 열린 구간으로 세 가지가 있습니다. 먼저 열린 구간은 (a, b)로 표현되며 a<i<b를 나타냅니다. 닫힌 구간은 [a,b]로 표현되며 a≤i≤b 를 나타냅니다. 이 두 가지 방법에는 모두 단점이 있습니다. 열린 구간의 경우 배열의 첫 번째 원소부터 시작하는 범위를 표현하고 싶다면 범위의 시작을 첫 번째 원소보다 이전인 가상의 원소를 시작으로 해야된다는 단점이 있습니다. 0인 인덱스를 범위 안에 포함시키고 싶다면 -1을 범위의 시작으로 해야할 것입니다. 닫힌 구간은 공집합을 직관적으로 표현하지 못하게 됩니다. 그래서 대부분의 프로그래밍 언어들은 두 방법의 절충안인 반 열린 구간을 사용합니다. 반 열린 구간은 [a, b)로 표현되며 a≤i<b를 나타냅니다. 프로그래밍 언어에서 반 열린 구간을 사용하는 예시는 다음과 같습니다.

🟢 C++ STL에서는 반복자로 범위를 표현할 때 첫 원소를 가리키는 반복자와 마지막 원소의 다음 위치를 가리키는 반복자를 사용합니다. 예를 들어 원소의 범위를 begin(), end()로 표현할 때 begin()은 첫 번째 원소를 가리키지만 end()는 마지마 원소가 아닌 마지막 원소 다음인 가상의 원소를 가리킵니다.

🟢 자바의 SortedSet 인터페이스는 범위를 fromElement와 toElement로 전달받는데, fromElement는 범위에 포함되지만 toElement는 범위에 포함되지 않습니다.

🟢 파이썬에서는 배열의 일부를 a[3:9]와 같은 문법으로 잘라내면 a[3]부터 a[8]까지 포함된 배열을 얻을 수 있습니다.

프로그래밍 언어가 지원하는 표현 방식과 다른 방식으로 함수를 사용한다면 함수 안에서와 밖에서의 표현 방식이 달라 혼란스러울 수 있기 때문에 프로그래밍 언어가 지원하는 표현 방식을 사용하는 것이 가장 효율적일 것입니다.

<br>

- off-by-one 오류

off-by-one의 오류는 범위의 크기를 계산할 때 하나가 적거나 많을 때 생기는 오류입니다. off-by-one 오류는 반복문에서 연산자를 혼용하여 사용할 때 자주 발생합니다. 반복문에서 최소 입력이 주어졌을 때 어떻게 동작할지를 생각하면서 코드를 작성한다면 off-by-one의 오류를 방지할 수 있습니다.
<br><br>

- 컴파일러가 잡아주지 못하는 상수 오타

변수명이나 함수명에서 낸 오타는 컴파일러가 찾아주기 때문에 코드를 작성할 때 오타에 대해 걱정하지 않는 경우가 많습니다. 하지만 상수를 잘못 입력한다면 결과값이 달라지기 때문에 맞는 코드를 작성해도 결과가 틀리는 경우가 발생합니다. 예를 들어 코드와 데이터를 분리하기 위해 데이터 배열을 따로 만드는 경우 데이터 배열을 선언할 때 잘못 입력한다면 틀린 결과에 대해 오류를 찾기 어려울 것입니다. 또한 정수형 상수는 32비트가 기본 값이므로 다른 비트 수를 사용할 때 따로 지정해주지 않는 경우 오류를 찾기 어려울 것입니다.
<br><br>

`상수 오타외에도 제가 코드를 작성한 경험을 생각해봤을 때 다른 많은 오타가 생길 수 있습니다. 변수명이나 함수명이 비슷한 경우 반복문이나 조건문에서 변수를 사용할 때 자동완성으로 잘못 선언되거나 함수 안에서 함수를 참조할 때 다른 함수를 참조하게 된다면 오류가 생길 수 있습니다. 단순 오타에 대해서는 오류를 찾기 어렵기 때문에 변수명, 함수명을 선언할 때부터 사용할 때까지 주의를 기울여 오류를 만들지 않도록 하는 것이 좋습니다.`

<br>

- 스택 오버플로

프로그램 실행 중 콜 스택(call stack)이 오버플로해서 프로그램이 강제종료되는 경우도 흔히 발생합니다. 스택 오버플로는 보통 재귀 호출의 깊이가 너무 깊어졌을 때 발생합니다. 스택의 최대 크기는 컴파일이나 실행시에 설정 가능하고 기본 값이 언어나 아키텍처 등에 따라 달라지기 때문에 문제에서 주어진 조건 등에 대해 미리 알아둘 필요가 있습니다.

c++의 경우 지역 변수로 선언한 배열이나 클래스 인스턴스가 기본적으로 스택 메모리를 사용하기 때문에 특히 스택 오버플로를 조심해합니다. 배열같은 큰 지역 변수를 스택에 잡으면 적은 재귀 호출로도 스택 오버플로가 나기 쉽기 때문에 대부분의 사람들이 자동으로 힙에 메모리를 할당하는 STL 컨테이너나 전역 변수를 사용하곤 합니다.
<br><br>

- 다차원 배열 인덱스 순서 바꿔쓰기

평소에는 2차원 이상의 다차원 배열을 사용할 일이 없지만 문제에 따라 4,5차원 이상의 고차원 배열을 사용하는 경우가 있습니다. 고차원의 배열을 많은 곳에서 사용하게 되면 2차원 이하의 배열에서보다 인덱스의 순서를 잘못쓰기 쉽습니다. 그러므로 가능한 특정 배열에 접근하는 위치를 하나로 통일하는 것이 좋습니다.
<br><br>

- 잘못된 비교 함수 작성

c++ 표준 라이브러리는 비교 함수가 < 연산자와 같은 방식으로 동작한다고 예상합니다. < 연산자의 성질은 다음과 같습니다.
<br><br>

1. a<a는 항상 거짓입니다. 이 성질을 비반사성(irreflexivity)이라고 합니다.
2. a<b가 참이면 b<a는 거짓입니다. 이 성질을 비대칭성(asymmetry)이라고 합니다.
3. a<b가 참이고 b<c가 참이면 a<c입니다. 이 성질을 전이성(transitivity)이라고 합니다.
4. a<b와 b<a가 모두 거짓이면 a와 b는 같은 값으로 간주합니다. a와 b가 같고 b와 c가 같다면 a와 c도 같아야 합니다. 이 성질을 상등 관계의 전이성(transitivity of equivalence)이라고 합니다.
   <br><br>

일반적인 상수 비교에서는 위의 성질을 모두 만족하지만 집합 등 상수 이외에 비교에서는 오류를 범하지 않기 위해 추가적인 조건이 필요합니다. 자세히 말하자면 집합의 포함 여부를 비교하기 위해 {1}과 {2}를 비교한다면 두 집합은 {1}<{2}, {2}<{1} 모두 거짓이므로 {1}={2}라고 판단하게 됩니다. 하지만 두 집합은 다른 집합이기에 완전히 같은 집합이 아니라면 a<b, b<a가 모두 거짓이라도 a=b라고 판단하지 않도록 해야합니다.

또한 연산자의 성질 이외에도 표준 라이브러리에서 지정한 비교 함수의 정의를 잘 살펴보아야 합니다. 자바의 경우 c++과 다르게 표준 라이브러리가 < 연산 대신에 ≤ 연산을 비교 함수의 모델로 사용하기 때문에 언어를 번갈아 쓸 경우 헷갈리지 않도록 유의해야 합니다.
<br><br>

- 최소, 최대 예외 잘못 다루기

예외란 말 그래로 정의된 조건에 제외되는 대상이나 조건이 있는 것을 말하기 때문에 예외를 제대로 처리하지 못했다는 것을 일반적인 실수라고 하기 어렵습니다. 하지만 가능한 입력 중 최소 값과 최대 값이 예외가 되는 꽤 많기 때문에 코드를 작성할 때 최소, 최대값에 대해 유의해야 합니다.
<br><br>

- 연산자 우선순위 잘못 쓰기

연산자 우선순위를 잘못 쓰는 실수 또한 찾기 어려운 오류 중 하나입니다. 사칙연산의 우선순위에 대해서는 잘 알고 있지만 시프트 연산자나 비트 단위 연산자들의 우선순위는 종종 헷갈리는 경우가 있습니다. 따라서 연산자의 우선순위를 잘 기억하거나 헷갈리는 경우 괄호를 사용하는 것이 좋습니다.
<br><br>

- 너무 느린 입출력 방식 선택

대부분의 프로그래밍 언어에는 다양한 입출력 방식이 존재합니다. cin 등의 고수준 입력 방식을 사용한다면 코드가 간단해지지만 gets() 등의 저수준 방식보다 속도가 느린 문제점이 발생합니다. 따라서 입출력의 양에 따라 입출력 방식을 잘 선택하는 것이 중요합니다.
<br><br>

- 변수 초기화 문제

같은 이름의 변수를 여러 군데에서 사용하는 경우에 다른 용도로 쓰이는 곳에서 변수를 초기화하지 않고 사용하는 경우가 있습니다. 특히 변수를 선언할 때 직접 초기화하지 않고 자동으로 생성되는 기본 값에 변수 초기화를 맡긴다면 이런 실수를 하는 경우가 더 많을 것입니다. 따라서 새로운 곳에서 변수를 사용할 때마다 적절한 값으로 변수를 초기화하여 코드를 작성해야 합니다.
