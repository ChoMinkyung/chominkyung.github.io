---
toc: true
toc_label: "Table of Contents"
toc_icon: "cog"
toc_sticky: true

layout:
title: "[알고리즘 문제 해결 전략] 4 알고리즘의 시간 복잡도 분석(1)"
excerpt: "02 알고리즘 분석 - 4 알고리즘의 시간 복잡도 분석 - 4.2 선형 시간 알고리즘, 4.3 선형 이하 시간 알고리즘, 4.4 지수 시간 알고리즘"
date: 2021-08-08
last_modified_at: 2021-08-08
categories:
  -
tags:
  - [알고리즘, 알고리즘 문제 해결 전략]

use_math: true
comments: true
share: false
---

📖[알고리즘 문제 해결 전략] 목차

<details>
<summary>01 문제 해결 시작하기</summary>
<div markdown="1">
  - [2 문제 해결 개관](/algorithmicProblemSolvingStrategies_01_2) <br>
  - [3 코딩과 디버깅에 관하여(1)](/algorithmicProblemSolvingStrategies_01_3(1)) <br>
  - [3 코딩과 디버깅에 관하여(2)](/algorithmicProblemSolvingStrategies_01_3(2))
</div>
</details>

<details>
<summary>02 알고리즘 분석</summary>
<div markdown="1">       
   - [4 알고리즘의 시간 복잡도 분석(1)](/algorithmicProblemSolvingStrategies_02_4(1)) <br>
   - [4 알고리즘의 시간 복잡도 분석(2)](/algorithmicProblemSolvingStrategies_02_4(2)) <br>
   - [5 알고리즘의 정당성 증명]() <br>
</div>
</details>

<details>
<summary>03 알고리즘 설계 패러다임</summary>
<div markdown="1">       
   - [6 무식하게 풀기]()<br>
   - [7 분할 정복]()<br>
   - [8 동적 계획법]()<br>
   - [9 동적 계획법 테크닉]()<br>
   - [10 탐욕법]()<br>
   - [11 조합 탐색]()<br>
   - [12 최적화 문제 결정 문제로 바꿔 풀기]()<br>
</div>
</details>

<details>
<summary>04 유명한 알고리즘들</summary>
<div markdown="1">
    - [13 수치 해석]()<br>
    - [14 정수론]()<br>
    - [15 계산 기하]() <br>
</div>
</details>

<details>
<summary>05 기초 자료 구조</summary>
<div markdown="1">
    - [16 비트마스크]()<br>
    - [17 부분 합]()<br>
    - [18 선형 자료 구조]()<br>
    - [19 큐와 스택, 데크]()<br>
    - [20 문자열]()<br>
</div>
</details>
 
<details>
<summary>06 트리</summary>
<div markdown="1">
    - [21 트리의 구현과 순회]()<br>
    - [22 이진 검색 트리]()<br>
    - [23 우선순위 큐와 힙]()<br>
    - [24 구간 트리]()<br>
    - [25 상호 배타적 집합]()<br>
    - [26 트라이]()<br>
</div>
</details>

<details>
<summary>07 그래프</summary>
<div markdown="1">
    - [27 그래프의 표현과 정의]()<br>
    - [28 그래프의 깊이 우선 탐색]()<br>
    - [29 그래프의 너비 우선 탐색]()<br>
    - [30 최단 경로 알고리즘]()<br>
    - [31 최소 스패닝 트리]()<br>
    - [32 네트워크 유량]()<br>
</div>
</details>

---

<div style="text-align: right"> 02 알고리즘 분석 </div>

## 4 알고리즘의 시간 복잡도 분석

[알고리즘](https://ko.wikipedia.org/wiki/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)이란 어떠한 문제를 풀기 위해 정해진 일련의 절차나 방법을 공식화한 형태로 표현한 것, 계산을 실행하기 위한 단계적 절차를 의미합니다. 즉, 문제 풀이에 필요한 계산 절차 또는 처리 과정의 순서를 뜻합니다. 가능한 한 명료하고 모호하지 않은 표현을 위해 사람들은 알고리즘을 대개 [수도 코드(pseudo-code)](https://ko.wikipedia.org/wiki/%EC%9D%98%EC%82%AC%EC%BD%94%EB%93%9C)나 그것을 구현한 소스 코드의 상태로 표현합니다. 그래서 처음에는 소스 코드와 알고리즘이 같은 것이라고 여기기 쉽습니다.

### 4.2 선형 시간 알고리즘

- 다이어트 현황 파악 : 이동 평균 계산하기

  이동 평균(moving average)는 주식의 가격, 몸무게 등 시간에 따라 변화하는 값들을 관찰할 때 유용하게 사용할 수 있는 통계적 기준입니다. 시간에 따라 관찰된 숫자들이 주어질 때 이동 평균값은 마지막 관찰된 숫자까지 포함하여 정의됩니다. 따라서 새 관찰 값이 나오면 이동 평균 역시 새 관찰 값을 포함하여 업데이트됩니다. 시간에 따라 관찰된 값이 늘어나게 되고, 모든 관찰 값을 단순한 연산으로 이동 평균을 계산한다면 계산량은 감당할 수 없을 만큼 커지게 될 것입니다.

  예를 들어 매달 값을 관찰하여 $N$개의 관찰 값이 주어질 때 지난 $M$달 간의 이동 평균을 계산하는 프로그램을 생각하여 봅시다. (예시: 1년 동안 달마다 관찰한 몸무게 - 12개의 관찰값, 3달 간의 이동 평균 – 1~3월의 몸무게 이동 평균, 2~4월의 몸무게 이동 평균, $...$)

  위와 같은 프로그램을 작성한다면 먼저 각 위치에서 지난 $M$개의 관찰 값의 합을 구하고 이를 $M$으로 나누어 각 위치의 이동 평균을 구하여 아래와 같은 코드를 작성할 수 있을 것입니다. 이때 수행 시간은 두 for문에 의해 결정될 것입니다. $j$를 사용하는 내부 반복문은 항상 $M$번 실행되고 $i$를 사용하는 외부 반복문은 $N-M+1$번 실행되니 전체 반복문은 $M(N-M+1) = NM-M^2+M$ 만큼 반복됩니다. $N$과 $M$의 숫자가 상대적으로 작을 때는 수행 시간이 길지 않을지 몰라도 두 값중 어느 하나라도 커지게 된다면 수행 시간은 급격하게 늘어나게 되어 느린 프로그램이 될 것입니다.

  ```c++
  //실수 배열 A가 주어질 때, 각 위치에서의 M-이동 평균을 구한다.
  vector<double> movingAverage1(const vector<double>& A, int M){
    vector<double> ret;
    int N = A.size();
    for(int i = M-1; i<N; ++i){
      //A[i]까지의 이동 평균 계산
      double partialSum = 0;
      for(int j = 0; j<M; ++j)
        partialSum += A[i-j];
      ret.push_back(partialSum)/M);
    }
    return ret;
  }
  ```

  어떻게 하면 더 빠른 프로그램을 짤 수 있을까요? 여기서 중요한 것은 중복된 계산을 없애는 것입니다. 각 위치에서 $M$달 간의 이동 평균을 구할 때 첫 번째 값을 제외한 합은 다음 위치에서도 또 계산된다는 것입니다. 즉, (전 위치) $M$개 관찰 값의 합에서 첫 번째 값을 제외하고 다음 위치의 관찰 값을 더해준다면 불필요한 계산을 줄일 수 있습니다. 이렇게 코드를 작성한다면 아래의 코드를 얻을 수 있고 반복문의 수행 시간은 $M-1+(N-M+1)=N$이 됩니다. 따라서 비선형이었던 수행 시간이 선형 수행 시간이 됩니다.  
  (\* [선형(linear)](https://ko.wikipedia.org/wiki/%EC%84%A0%ED%98%95%EC%84%B1) : 직선처럼 똑바른 도형, 또는 그와 비슷한 성직을 갖는 대상이라는 뜻으로 곡선이 아닌 직선, 1차를 의미합니다.)

  ```c++
  //길이가 N인 실수 배열 A가 주어질 때, 각 위치에서의 M-이동 평균을 구한다.
  vector<double> movingAverage2(const vector<double>& A, int M){
    vector<double> ret;
    int N = A.size();
    double partialSum = 0;
    for(int i = 0; i<M-1; ++i)
      partialSum += A[i-j];
    for(int i = M-1; j<N; ++j){
      partialSum += A[i-j];
      ret.push_back(partialSum)/M);
      partialSum -= A[i-M_1];
    }
    return ret;
  }
  ```

### 4.3 선형 이하 시간 알고리즘

- 성형 전 사진 찾기  
  문제와 상관없이 입력된 자료를 모두 한 번 훑어보는 데에는 입력의 크기에 비례하는 시간, 즉 선형 시간이 걸립니다. 선형 이하 시간을 갖는 알고리즘은 어떻게 동작할까요? 입력으로 주어진 자료에 대해 미리 알고 있는 지식이 있고 이를 활용 가능하다면 선형 이하 시간의 수행 시간이 걸릴 것입니다.

  예를 들어 한 사람의 성형 전부터 후까지 10만장의 사진이 있고 성형 시기를 찾고자 한다면 10만장의 사진을 다 보아야 할 것입니다. 하지만 더 좋은 방법은 가운데 사진을 확인하고 성형 전이라면 뒷부분을 성형 후라면 앞부분을 확인하여 보게 되는 사진의 수를 줄이는 것입니다. 이때 봐야하는 사진의 장수를 $N$이라고 할 때 몇 번이나 사진을 나누어 확인해야 하는지를 구하려면 로그를 사용하면 됩니다. 매번 절반씩 나누어지므로 밑이 2인 로그를 사용하여 표현합니다. 따라서 확인해야하는 사진의 수는 약 $log_{2}N$이라고 할 수 있습니다. 이와 같이 입력의 크기가 커지는 속도보다 수행 시간이 느리게 증가하는 알고리즘들을 선형 이하 시간(sublinear time)알고리즘이라고 합니다.

<br>

- 이진 탐색  
  위의 예시에서 사용한 알고리즘을 이진 탐색(binary search)라고 합니다. 이진 탐색은 오름차순으로 정렬된 리스트에서 중간의 값을 임의로 선택하여 찾고자 하는 값과 크고 작음을 비교하여 그 값의 위치를 찾는 알고리즘입니다. 식으로 표현하면 `binsearch(A[], x)`는 `A[i-1]<x≤A[i]`을 만족하는 $i$값을 반환합니다. 이때 `A[-1]=-∞, A[N]=∞`로 가정합니다. 즉, $A[]$에 $x$가 존재하는 경우 $x$의 첫 번째 위치를 반환하고 없는 경우에는 $x$보다 큰 첫 번째 원소의 위치를 반환하게 됩니다.

<br>

- 그래도 선형 시간 아닌가요?  
  하지만 위의 설명대로라면 사진을 다 탐색하여 오름차순으로 정렬해야 하고 사람이 성형 이전인지 이후인지 판단해야 합니다. 따라서 탐색 시간과 관계없이 문제 풀이에 걸리는 시간은 선형 시간으로 같은 것이 아닌가 하는 의문이 들 수 있습니다. 하지만 다음과 같은 이유로 선형 이하 시간 알고리즘이라고 말할 수 있습니다.

  첫 번째로 $A[]$를 실제로 계산해서 가지고 있을 필요가 없습니다. 이진 탐색의 설명에서는 편의상 $A[]$ 배열이 이미 계산되어 있다고 가정했지만, $A[]$를 다 계산하더라도 배열의 모든 원소를 다 사용하지 않습니다. 따라서 미리 계산하지 않고 비교할 때, $i$가 주어질 때 $A[i]$를 계산하여 필요한 계산만을 수행합니다.

  두 번째로 입력된 값을 정렬하는 것은 성형 전 사진을 찾는 작업과는 별개의 문제입니다. 같은 입력 값으로 여러 문제를 해결하는 경우가 많기에, 정렬하는 것과 문제를 해결하는 것을 별개로 여깁니다.

<br><br>

### 4.4 지수 시간 알고리즘

- 다항 시간 알고리즘  
  수학에서 한 개 이상의 항의 합으로 이루어진 식을 다항식이라고 합니다. 반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘을 다항 시간 알고리즘이라고 부르며 이 장에서 다룰 대부분 알고리즘이 그렇습니다. 예를 들어 수행 시간이 $N$, $N^2$인 알고리즘은 모두 다항 시간 알고리즘입니다. 선형 시간이나 선형 이하 시간 알고리즘과 달리 다항 시간 알고리즘으로 분류하는 것은 비효율적으로 느껴질 수 있습니다. 앞의 두 분류와 다르게 다항 시간 알고리즘은 $N$부터 $N^{100}$까지 심지어는 더 큰 지수를 가지고 있는 수행 시간도 포함하기 때문입니다. 하지만 굳이 이렇게 분류를 하는 이유는 다항 시간 알고리즘보다도 더 오랜 시간이 걸리는 알고리즘이 있기 때문입니다.

<br>

- 알러지가 심한 친구들  
  집들이에 $N$명의 친구를 초대하려고 합니다. 할 줄 아는 $M$가지의 음식 중 무엇을 대접해야 할까 고민하는데 친구들은 각각 알러지 때문에 못 먹는 음식들이 있어서 아무 음식이나 해서는 안 됩니다. 한 가지 음식으로는 모두가 먹을 수 없기에 모두가 먹으려면 적어도 두 가지 이상 음식을 해야 합니다. 이 내용을 표로 정리하여 보면 다음과 같습니다.

  |        | 갈비찜 | 피자 | 잡채 | 떡볶이 | 탕수육 | 닭강정 |
  | :----- | :----: | :--: | :--: | :----: | :----: | :----: |
  | 장그래 |   X    |  O   |  O   |   O    |   X    |   X    |
  | 안영이 |   X    |  X   |  X   |   X    |   O    |   O    |
  | 한석율 |   O    |  X   |  O   |   X    |   O    |   X    |
  | 장백기 |   O    |  O   |  X   |   X    |   X    |   O    |

<br>

- 모든 답 후보를 평가하기  
  이 문제에서 조건에 따라 답이 달라질 것입니다. 만들 수 있는 모든 음식을 한다면 모두가 먹을 수 있을 것입니다. 하지만 더 좋은 답, 더 적은 종류의 음식만을 준비하고자 합니다. 이렇게 여러 개의 답이 있고 그중 가장 좋은 답을 찾는 간단한 방법은 모든 답을 일일이 고려하는 것입니다. 만들 음식의 목록을 정하는 방법은 음식마다 만들지 말지를 결정하는 것입니다. 이것을 그림과 코드로 표현하면 다음과 같습니다.

  ![4.4-picture1.PNG](https://user-images.githubusercontent.com/58170545/128634517-db64532f-0c20-4ac5-8d99-0916e714ea10.PNG){: .align-center}

  ```c++
  const int INF = 987654321;
  //이 메뉴로 모두가 식사할 수 있는지 여부를 반환
  bool canEverybodyEat(const vector<int>& menu);
  int M; // 요리 가능한 메뉴 수
  //food 번째 음식을 만들지 여부를 결정
  int selectMenu(vector<int>& menu, int food){
    //기저 사례 : 모든 음식에 대해 만들지 여부를 결정했을 때
    if(food==M){
      if(cnaEverybodyEat(menu)) return menu.size();
      return INF; // 아무것도 못 먹는 사람이 있으면 아주 큰 값을 반환
    }
    //이 음식을 만드는 경우의 답을 계산해서 더 작은 것을 취함
    menu.push_back(bood);
    ret = min(ret, selectMenu(menu, food+1));
    menu.pop_back();
    return ret;
  }
  ```

<br>

- 지수 시간 알고리즘  
  현재 프로그램은 모든 답을 한 번씩 다 확인하기 때문에 전체 수행 시간은 만들 수 있는 답의 수에 비례하게 됩니다. $M$가지의 음식마다 두 선택지가 있으므로 만들 수 있는 답은 모두 $2^M$가지입니다. 답을 하나 만들 때마다 `canEverybodyEat()`을 수행하기에 이 알고리즘의 수행 시간은 $2^M$에 `canEverybodyEat()`의 수행 시간을 곱한 것이 됩니다. `canEverybodyEat()`의 수행 시간이 $N·M$이라고 가정할 때 전체 수행 시간은 $N·M·2^M$이 됩니다.

  $2^M$ 같은 지수 함수는 알고리즘의 전체 수행 시간에 큰 영향을 미치게 됩니다. 지수 함수의 특성상 지수가 커질수록 함수의 값이 기하급수적으로 커지기 때문입니다. 이렇게 큰 수행 시간을 갖는 것이 알고리즘의 문제라고 생각할 수 있지만, 지수 시간보다 더 빠른 수행 시간을 찾을 수 없는 알고리즘이 아주 많고 지수 시간 알고리즘을 사용한 문제들을 [집합 덮개 문제(set cover)](https://ko.wikipedia.org/wiki/%EC%A7%91%ED%95%A9_%EB%8D%AE%EA%B0%9C_%EB%AC%B8%EC%A0%9C)라고 부릅니다. 집합 덮개 문제는 아직 다항 시간 알고리즘이 존재한다는 증거도, 존재하지 않는다는 증거도 발견되지 않았습니다. 따라서 다항 시간, 지수 시간으로 분류하는 것은 현재의 전산학에서 효율적으로 해결할 수 있는 문제인지를 판단하는 경계역할을 하고 있습니다.

<br>

- 소인수 분해의 수행 시간  
  입력의 수가 아니라 입력의 크기에 따라 수행 시간이 달라지는 알고리즘 또한 지수 수행 시간을 가질 수 있습니다. 예를 들어 아래와 같은 코드가 있습니다. 아래 코드는 자연수 $N$이 입력으로 주어질 때 $N$이 1이 될 때까지 나눠 소인수 분해 결과를 출력하는 알고리즘입니다. 이 코드는 2부터 1씩 더한 수로 나누어 동작하므로 만약 $N$이 소수라면 $N-1$의 수행 시간을 갖게 됩니다.

  ```c++
  //자연수 n의 소인수 분해 결과를 담은 정수 배열을 반환
  vector<int> factor(int n){
    if(n==1) return vector<int>(1,1); //n=1인 경우는 예외
    vector<int> ret;
    for(int div=2; n>1; ++div)
      while(n%div==0){
        n /= div;
        ret.push_back(div);
      }
      return ret;
  }
  ```

  수행 시간이 $N-1$이라고 해서 선형 시간이라고 생각할 수 있지만, 이 경우에 알고리즘의 수행 시간 뿐만 아니라 입력이 메모리에서 차지하는 공간까지 생각해야 합니다. 이 문제는 입력은 하나이지만 입력의 크기는 정해져 있지 않기 때문에 입력이 커지면 저장하는데 필요한 메모리의 공간도 증가할 것입니다. 비트의 수가 하나 증가할 때마다 표현할 수 있는 수의 범위와 알고리즘의 최대 수행 시간은 두 배로 증가하게 됩니다. 따라서 이 알고리즘도 지수 시간 알고리즘이라고 할 수 있습니다.
