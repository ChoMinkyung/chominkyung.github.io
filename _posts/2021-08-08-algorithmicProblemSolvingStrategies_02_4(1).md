---
toc: true
toc_label: "Table of Contents"
toc_icon: "cog"
toc_sticky: true

layout:
title: "[알고리즘 문제 해결 전략] 4 알고리즘의 시간 복잡도 분석(1)"
excerpt: "02 알고리즘 분석 - 4 알고리즘의 시간 복잡도 분석 - 4.2 "
date: 2021-08-08
last_modified_at: 2021-08-08
categories:
  -
tags:
  - [알고리즘, 알고리즘 문제 해결 전략]

use_math: true
comments: true
share: false
---

📖[알고리즘 문제 해결 전략] 목차

<details>
<summary>01 문제 해결 시작하기</summary>
<div markdown="1">
  - [2 문제 해결 개관](/algorithmicProblemSolvingStrategies_01_2) <br>
  - [3 코딩과 디버깅에 관하여(1)](/algorithmicProblemSolvingStrategies_01_3(1)) <br>
  - [3 코딩과 디버깅에 관하여(2)](/algorithmicProblemSolvingStrategies_01_3(2))
</div>
</details>

<details>
<summary>02 알고리즘 분석</summary>
<div markdown="1">       
   - [4 알고리즘의 시간 복잡도 분석(1)](/algorithmicProblemSolvingStrategies_02_4(1)) <br>
   - [4 알고리즘의 시간 복잡도 분석(2)](/algorithmicProblemSolvingStrategies_02_4(2)) <br>
   - [5 알고리즘의 정당성 증명]() <br>
</div>
</details>

<details>
<summary>03 알고리즘 설계 패러다임</summary>
<div markdown="1">       
   - [6 무식하게 풀기]()<br>
   - [7 분할 정복]()<br>
   - [8 동적 계획법]()<br>
   - [9 동적 계획법 테크닉]()<br>
   - [10 탐욕법]()<br>
   - [11 조합 탐색]()<br>
   - [12 최적화 문제 결정 문제로 바꿔 풀기]()<br>
</div>
</details>

<details>
<summary>04 유명한 알고리즘들</summary>
<div markdown="1">
    - [13 수치 해석]()<br>
    - [14 정수론]()<br>
    - [15 계산 기하]() <br>
</div>
</details>

<details>
<summary>05 기초 자료 구조</summary>
<div markdown="1">
    - [16 비트마스크]()<br>
    - [17 부분 합]()<br>
    - [18 선형 자료 구조]()<br>
    - [19 큐와 스택, 데크]()<br>
    - [20 문자열]()<br>
</div>
</details>
 
<details>
<summary>06 트리</summary>
<div markdown="1">
    - [21 트리의 구현과 순회]()<br>
    - [22 이진 검색 트리]()<br>
    - [23 우선순위 큐와 힙]()<br>
    - [24 구간 트리]()<br>
    - [25 상호 배타적 집합]()<br>
    - [26 트라이]()<br>
</div>
</details>

<details>
<summary>07 그래프</summary>
<div markdown="1">
    - [27 그래프의 표현과 정의]()<br>
    - [28 그래프의 깊이 우선 탐색]()<br>
    - [29 그래프의 너비 우선 탐색]()<br>
    - [30 최단 경로 알고리즘]()<br>
    - [31 최소 스패닝 트리]()<br>
    - [32 네트워크 유량]()<br>
</div>
</details>

---

<div style="text-align: right"> 02 알고리즘 분석 </div>

## 4 알고리즘의 시간 복잡도 분석

[알고리즘](https://ko.wikipedia.org/wiki/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)이란 어떠한 문제를 풀기 위해 정해진 일련의 절차나 방법을 공식화한 형태로 표현한 것, 계산을 실행하기 위한 단계적 절차를 의미합니다. 즉, 문제 풀이에 필요한 계산 절차 또는 처리 과정의 순서를 뜻합니다. 가능한 한 명료하고 모호하지 않은 표현을 위해 사람들은 알고리즘을 대개 [수도 코드(pseudo-code)](https://ko.wikipedia.org/wiki/%EC%9D%98%EC%82%AC%EC%BD%94%EB%93%9C)나 그것을 구현한 소스 코드의 상태로 표현합니다. 그래서 처음에는 소스 코드와 알고리즘이 같은 것이라고 여기기 쉽습니다.

### 4.2 선형 시간 알고리즘

- 다이어트 현황 파악 : 이동 평균 계산하기

  이동 평균(moving average)는 주식의 가격, 몸무게 등 시간에 따라 변화하는 값들을 관찰할 때 유용하게 사용할 수 있는 통계적 기준입니다. 시간에 따라 관찰된 숫자들이 주어질 때 이동 평균값은 마지막 관찰된 숫자까지 포함하여 정의됩니다. 따라서 새 관찰 값이 나오면 이동 평균 역시 새 관찰 값을 포함하여 업데이트됩니다. 시간에 따라 관찰된 값이 늘어나게 되고, 모든 관찰 값을 단순한 연산으로 이동 평균을 계산한다면 계산량은 감당할 수 없을 만큼 커지게 될 것입니다.

  예를 들어 매달 값을 관찰하여 $N$개의 관찰 값이 주어질 때 지난 $M$달 간의 이동 평균을 계산하는 프로그램을 생각하여 봅시다. (예시: 1년 동안 달마다 관찰한 몸무게 - 12개의 관찰값, 3달 간의 이동 평균 – 1~3월의 몸무게 이동 평균, 2~4월의 몸무게 이동 평균, $...$)

  위와 같은 프로그램을 작성한다면 먼저 각 위치에서 지난 $M$개의 관찰 값의 합을 구하고 이를 $M$으로 나누어 각 위치의 이동 평균을 구하여 아래와 같은 코드를 작성할 수 있을 것입니다. 이때 수행 시간은 두 for문에 의해 결정될 것입니다. $j$를 사용하는 내부 반복문은 항상 $M$번 실행되고 $i$를 사용하는 외부 반복문은 $N-M+1$번 실행되니 전체 반복문은 $M*(N-M+1)=N*M-M^2+M$만큼 반복됩니다. $N$과 $M$의 숫자가 상대적으로 작을 때는 수행 시간이 길지 않을지 몰라도 두 값중 어느 하나라도 커지게 된다면 수행 시간은 급격하게 늘어나게 되어 느린 프로그램이 될 것입니다.

  ```c++
  //실수 배열 A가 주어질 때, 각 위치에서의 M-이동 평균을 구한다.
  vector<double> movingAverage1(const vector<double>& A, int M){
    vector<double> ret;
    int N = A.size();
    for(int i = M-1; i<N; ++i){
      //A[i]까지의 이동 평균 계산
      double partialSum = 0;
      for(int j = 0; j<M; ++j)
        partialSum += A[i-j];
      ret.push_back(partialSum)/M);
    }
    return ret;
  }
  ```

  어떻게 하면 더 빠른 프로그램을 짤 수 있을까요? 여기서 중요한 것은 중복된 계산을 없애는 것입니다. 각 위치에서 $M$달 간의 이동 평균을 구할 때 첫 번째 값을 제외한 합은 다음 위치에서도 또 계산된다는 것입니다. 즉, (전 위치) $M$개 관찰 값의 합에서 첫 번째 값을 제외하고 다음 위치의 관찰 값을 더해준다면 불필요한 계산을 줄일 수 있습니다. 이렇게 코드를 작성한다면 아래의 코드를 얻을 수 있고 반복문의 수행 시간은 $M-1+(N-M+1)=N$이 됩니다. 따라서 비선형이었던 수행 시간이 선형 수행 시간이 됩니다.  
  (\* [선형(linear)](https://ko.wikipedia.org/wiki/%EC%84%A0%ED%98%95%EC%84%B1) : 직선처럼 똑바른 도형, 또는 그와 비슷한 성직을 갖는 대상이라는 뜻으로 곡선이 아닌 직선, 1차를 의미합니다.)

  ```c++
  //길이가 N인 실수 배열 A가 주어질 때, 각 위치에서의 M-이동 평균을 구한다.
  vector<double> movingAverage2(const vector<double>& A, int M){
    vector<double> ret;
    int N = A.size();
    double partialSum = 0;
    for(int i = 0; i<M-1; ++i)
      partialSum += A[i-j];
    for(int i = M-1; j<N; ++j){
      partialSum += A[i-j];
      ret.push_back(partialSum)/M);
      partialSum -= A[i-M_1];
    }
    return ret;
  }
  ```

### 4.3 선형 이하 시간 알고리즘

- 성형 전 사진 찾기  
  문제와 상관없이 입력된 자료를 모두 한 번 훑어보는 데에는 입력의 크기에 비례하는 시간, 즉 선형 시간이 걸립니다. 선형 이하 시간을 갖는 알고리즘은 어떻게 동작할까요? 입력으로 주어진 자료에 대해 미리 알고 있는 지식이 있고 이를 활용 가능하다면 선형 이하 시간의 수행 시간이 걸릴 것입니다.

  예를 들어 한 사람의 성형 전부터 후까지 10만장의 사진이 있고 성형 시기를 찾고자 한다면 10만장의 사진을 다 보아야 할 것입니다. 하지만 더 좋은 방법은 가운데 사진을 확인하고 성형 전이라면 뒷부분을 성형 후라면 앞부분을 확인하여 보게 되는 사진의 수를 줄이는 것입니다. 이때 봐야하는 사진의 장수를 $N$이라고 할 때 몇 번이나 사진을 나누어 확인해야 하는지를 구하려면 로그를 사용하면 됩니다. 매번 절반씩 나누어지므로 밑이 2인 로그를 사용하여 표현합니다. 따라서 확인해야하는 사진의 수는 약 $log_{2}N$이라고 할 수 있습니다. 이와 같이 입력의 크기가 커지는 속도보다 수행 시간이 느리게 증가하는 알고리즘들을 선형 이하 시간(sublinear time)알고리즘이라고 합니다.

- 이진 탐색  
  위의 예시에서 사용한 알고리즘을 이진 탐색(binary search)라고 합니다. 이진 탐색은 오름차순으로 정렬된 리스트에서 중간의 값을 임의로 선택하여 찾고자 하는 값과 크고 작음을 비교하여 그 값의 위치를 찾는 알고리즘입니다. 식으로 표현하면 `binsearch(A[], x)`는 `A[i-1]<x≤A[i]`을 만족하는 $i$값을 반환합니다. 이때 `A[-1]=-∞, A[N]=∞`로 가정합니다. 즉, $A[]$에 $x$가 존재하는 경우 $x$의 첫 번째 위치를 반환하고 없는 경우에는 $x$보다 큰 첫 번째 원소의 위치를 반환하게 됩니다.

- 그래도 선형 시간 아닌가요?  
  하지만 위의 설명대로라면 사진을 다 탐색하여 오름차순으로 정렬해야 하고 사람이 성형 이전인지 이후인지 판단해야 합니다. 따라서 탐색 시간과 관계없이 문제 풀이에 걸리는 시간은 선형 시간으로 같은 것이 아닌가 하는 의문이 들 수 있습니다. 하지만 다음과 같은 이유로 선형 이하 시간 알고리즘이라고 말할 수 있습니다.

  첫 번째로 $A[]$를 실제로 계산해서 가지고 있을 필요가 없습니다. 이진 탐색의 설명에서는 편의상 $A[]$ 배열이 이미 계산되어 있다고 가정했지만, $A[]$를 다 계산하더라도 배열의 모든 원소를 다 사용하지 않습니다. 따라서 미리 계산하지 않고 비교할 때, $i$가 주어질 때 $A[i]$를 계산하여 필요한 계산만을 수행합니다.

  두 번째로 입력된 값을 정렬하는 것은 성형 전 사진을 찾는 작업과는 별개의 문제입니다. 같은 입력 값으로 여러 문제를 해결하는 경우가 많기에, 정렬하는 것과 문제를 해결하는 것을 별개로 여깁니다.
